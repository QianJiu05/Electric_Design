//11111111

// 1phase bridgeless pfc use sogi pll 


#include "math.h"

#define  float float

#define FSW 20e3

#define ssrf_ts             1/FSW
#define ssrf_kp             0.9f
#define sser_ki             0.0001f
#define ssrf_up_limt        63
#define ssrf_low_limt       43
#define value_2pi           2.0f * 3.1415926

//[0.003405429629029,0,-0.003405429629029]
//[0.010982881827120,0,-0.010982881827120]
#define SIGO_U_GAIN  1
#define SIGO_U_B0    0.010982881827120 
#define SIGO_U_B1    0
#define SIGO_U_B2   -0.010982881827120

//[1,-1.993165860418354,0.993189140741942]
//[1,-1.977790221205283,0.978034236345759]
#define SIGO_U_A1   -1.977790221205283
#define SIGO_U_A2    0.978034236345759

//qu coeff [8.229594388365577e-06,1.645918877673115e-05,8.229594388365577e-06]
//[8.625935215831610e-05,1.725187043166322e-04,8.625935215831610e-05]
#define SIGO_QU_GAIN  1.0e-03
#define SIGO_QU_B0    0.08625935215831610 
#define SIGO_QU_B1    0.1725187043166322
#define SIGO_QU_B2    0.08625935215831610

//q coef  [1,-1.993165860418354,0.993189140741942]
//[1,-1.977790221205283,0.978034236345759]
#define SIGO_QU_A1    -1.977790221205283
#define SIGO_QU_A2     0.978034236345759

//
//Const data define 
//
typedef struct DIS_2ORDER_TF_COEF_TAG {
    float gain;
    float B0;
    float B1;
    float B2;
    float A1;
    float A2;
}DIS_2ORDER_TF_COEF_DEF;

typedef struct DIS_2ORDER_TF_DATA_TAG {
    float output;
    float w0;
    float w1;
    float w2;
}DIS_2ORDER_TF_DATA_DEF;


//
// SOGI PLL date struct
//
typedef struct SOGI_PLL_DATA_STRUCT_TAG
{
    float ac_u;
    float ac_qu;
    float u_q;
    float u_d;
    float theta;
    float theta_1;
    float cos_theta;
    float sin_theta;
    float grid_freq;
    float pll_freq_out;
    float delta_t;
    float spll_diff;

    DIS_2ORDER_TF_COEF_DEF  sogi_u_coeff;
    DIS_2ORDER_TF_DATA_DEF  sogi_u_data;

    DIS_2ORDER_TF_COEF_DEF  sogi_qu_coeff;
    DIS_2ORDER_TF_DATA_DEF  sogi_qu_data;

    DIS_2ORDER_TF_DATA_DEF  sogi_alpha_data;
    DIS_2ORDER_TF_DATA_DEF  sogi_beta_data;
    DIS_2ORDER_TF_COEF_DEF  sogi_alpha_coeff;
    DIS_2ORDER_TF_COEF_DEF  sogi_beta_coeff;

    float spll_kp;
    float spll_ki;
    float spll_integrator;
    float spll_freq_min_limt;
    float spp_freq_max_limt;
}SOGI_PLL_DATA_DEF;

SOGI_PLL_DATA_DEF spll_data;

// Function description :
void sogi_pll_init(SOGI_PLL_DATA_DEF *spll_obj, float grid_freq, float ts)
{
    spll_obj->grid_freq = grid_freq;
    spll_obj->delta_t = ts;

    spll_obj->sogi_u_coeff.gain = SIGO_U_GAIN;
    spll_obj->sogi_u_coeff.B0 = SIGO_U_B0;
    spll_obj->sogi_u_coeff.B1 = SIGO_U_B1;
    spll_obj->sogi_u_coeff.B2 = SIGO_U_B2;

    spll_obj->sogi_u_coeff.A1 = SIGO_U_A1;
    spll_obj->sogi_u_coeff.A2 = SIGO_U_A2;

    spll_obj->sogi_qu_coeff.gain = SIGO_QU_GAIN;
    spll_obj->sogi_qu_coeff.B0 = SIGO_QU_B0;
    spll_obj->sogi_qu_coeff.B1 = SIGO_QU_B1;
    spll_obj->sogi_qu_coeff.B2 = SIGO_QU_B2;

    spll_obj->sogi_qu_coeff.A1 = SIGO_QU_A1;
    spll_obj->sogi_qu_coeff.A2 = SIGO_QU_A2;

    spll_obj->spll_kp = ssrf_kp;
    spll_obj->spll_ki = sser_ki;
    spll_obj->spp_freq_max_limt = ssrf_up_limt;
    spll_obj->spll_freq_min_limt = ssrf_low_limt;

    /* α 通道 */
    spll_obj->sogi_alpha_coeff = spll_obj->sogi_u_coeff;   // 直接复制即可
    /* β 通道 */
    spll_obj->sogi_beta_coeff  = spll_obj->sogi_u_coeff;
}

// sogi_pll_init(&spll_data, 50.0, ssrf_ts);


float  discrete_2order_tf(const float input, DIS_2ORDER_TF_COEF_DEF *coeff, DIS_2ORDER_TF_DATA_DEF *data)
{
    // w0 = x(0) - A1 * W1 - A2 * W2
    data->w0 = input - coeff->A1 * data->w1 - coeff->A2 * data->w2;

    // Y(0) = Gain * (B0 * W0 + B1 * W1 + B2 * W2)
    data->output = coeff->gain * (coeff->B0 * data->w0 + coeff->B1 * data->w1 + coeff->B2 * data->w2);

    data->w2 = data->w1;
    data->w1 = data->w0;

    return(data->output);           
}


// sogo pll 
void spll_sogi_func(SOGI_PLL_DATA_DEF *spll_obj, float va, float vb, float vc)
{
    /* 1. Clarke 变换 -> α, β */
    float valpha = va;
    float vbeta  = (vb - vc) * 0.57735;   // 1/√3 ≈ 0.57735
    /* 2. SOGI 产生正交信号 */
    float u_alpha = discrete_2order_tf(valpha,
                          &spll_obj->sogi_alpha_coeff,
                          &spll_obj->sogi_alpha_data);
    float u_beta  = discrete_2order_tf(vbeta,
                          &spll_obj->sogi_beta_coeff,
                          &spll_obj->sogi_beta_data);

    /* 3. Park 变换（用 SOGI 输出作为 αβ，再转到 dq） */
    spll_obj->u_d =  u_alpha * spll_obj->cos_theta
                   + u_beta  * spll_obj->sin_theta;
    spll_obj->u_q = -u_alpha * spll_obj->sin_theta
                   + u_beta  * spll_obj->cos_theta;

    // /* 4. 以下 PLL 部分完全不用改 */
    spll_obj->spll_diff = 0.0f - spll_obj->u_q;   // 让 u_q → 0
    
    spll_obj->spll_integrator += spll_obj->spll_diff * spll_obj->spll_ki;
    
    spll_obj->pll_freq_out = spll_obj->spll_diff * spll_obj->spll_kp + spll_obj->spll_integrator;

 /* 5. 角度更新 & 归一化 */
    spll_obj->theta += spll_obj->pll_freq_out * value_2pi * spll_obj->delta_t;

    if (spll_obj->theta > value_2pi)    spll_obj->theta -= value_2pi;
    else if (spll_obj->theta < 0)   spll_obj->theta += value_2pi;

    // // pi ctrol q to 0
    // spll_obj->spll_diff = 0 - spll_obj->u_d;

    // spll_obj->theta -= (spll_obj->pll_freq_out+0.5f) * value_2pi * spll_obj->delta_t;


    spll_obj->cos_theta = cos(spll_obj->theta);
    spll_obj->sin_theta = sin(spll_obj->theta);
}


//222222
//init code
 sogi_pll_init(&spll_data, 50*value_2pi, ssrf_ts);






//33333
//while1
float va = InputSignal(0, 0);   // A 相
    float vb = InputSignal(0, 1);   // B 相
    float vc = InputSignal(0,2);   // C 相

    // 2) 运行三相 SOGI-PLL
    spll_sogi_func(&spll_data, va, vb, vc);

    // 3) 输出结果
    OutputSignal(0, 0) = spll_data.theta;          // 0 … 2π
    OutputSignal(0, 1) = spll_data.pll_freq_out;   // Hz
    OutputSignal(0, 2) = spll_data.u_q;            // PI 误差（调试用）







//park 1
#include <stdio.h>
#include <math.h>

    // 定义变量
    double phi; // 角度phi
    double xa, xb, xc; // 输入向量的元素
    double yd, yq; // 输出向量的元素


//park3
#define M_PI 3.141592617
    
    float xa = InputSignal(0, 0);
    float xb = InputSignal(0, 1);
    float xc = InputSignal(0, 2);
    float phi = InputSignal(1,0);
    


    // 计算矩阵乘法
    yd = (2.0 / 3.0) * (cos(phi) * xa + cos(phi-2/3*M_PI) * xb + xc* cos(phi+2/3*M_PI));
    yq = (2.0 / 3.0) * (-sin(phi) * xa  - sin(phi-2/3*M_PI) * xb - sin(phi+2/3*M_PI)*xc);
    
   
    OutputSignal(0, 0) = yd;
    OutputSignal(0, 1) = yq;

    
